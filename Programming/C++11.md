
# New Language
## performance enhancements
### Rvalue references
```
Remember that “&&” indicates a universal reference only where type deduction takes place.  
Where there’s no type deduction, there’s no universal reference.  
In such cases, “&&” in type declarations always means rvalue reference. 

Universal references can only occur in the form “T&&”!  
Even the simple addition of a const qualifier is enough to disable 
the interpretation of “&&” as a universal reference.
```

E.g.

```
void foo(int &&) {
}

template<class T>
void bar(const T &&) {
}

...

int val = 1;
foo(val); // error: cannot bind ‘int’ lvalue to ‘int&&’
bar(val); // error: cannot bind ‘int’ lvalue to ‘int&&’

foo(1); // correct
bar(1); // correct

foo(std::move(val)); // correct
bar(std::move(val)); // correct
```

See detail in [Universal References](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers).

[The new C++ 11 rvalue reference && and why you should start using it](https://www.codeproject.com/Articles/453022/The-new-Cplusplus-rvalue-reference-and-why-you)

## usability enhancements
### Type inference
```
auto x = sqrt(2); 
// range for loop
for (auto x : v) cout << x;
// rvalue reference
```

# New Library

# Q&A
1. Why to have rvalue reference?

# References
1. [C++11 - Wikipedia](https://en.wikipedia.org/wiki/C%2B%2B11)
2. [C++11 - the new ISO C++ standard](http://www.stroustrup.com/C++11FAQ.html)
